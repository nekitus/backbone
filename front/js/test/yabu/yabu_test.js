// Generated by CoffeeScript 1.3.3

describe('Model (creation)', function() {
  var model;
  model = new bg.yabu.model();
  it('can be constructed', function() {
    return expect(model).toBeDefined();
  });
  it('has "set" method', function() {
    return expect(model.set instanceof Function).toBeTruthy();
  });
  it('has "get" method', function() {
    return expect(model.get instanceof Function).toBeTruthy();
  });
  it('has "onChange" method', function() {
    return expect(model.onChange instanceof Function).toBeTruthy();
  });
  it('has "offChange" method', function() {
    return expect(model.offChange instanceof Function).toBeTruthy();
  });
  it('has "bind" method', function() {
    return expect(model.bind instanceof Function).toBeTruthy();
  });
  return it('can set data in constructor', function() {
    var initData;
    initData = {
      id: 1,
      name: 'test'
    };
    model = new bg.yabu.model(initData);
    expect(model.get('id')).toBe(1);
    return expect(model.get('name')).toBe('test');
  });
});

describe('Model (get-set)', function() {
  it('can set single property and get it back', function() {
    var model;
    model = new bg.yabu.model({
      id: 1
    });
    model.set('test', 1);
    return expect(model.get('test')).toBe(1);
  });
  return it('can set multiple properties and get it back', function() {
    var initData, model;
    model = new bg.yabu.model();
    initData = {
      id: 1,
      name: 'test'
    };
    model.set(initData);
    expect(model.get('id')).toBe(1);
    return expect(model.get('name')).toBe('test');
  });
});

describe('Model onChange', function() {
  var callback1, callback2, fired1, fired2, model;
  model = null;
  fired1 = 0;
  fired2 = 0;
  callback1 = function() {
    return fired1++;
  };
  callback2 = function() {
    return fired2++;
  };
  beforeEach(function() {
    model = new bg.yabu.model({
      id: 1,
      name: 'test',
      x: 0,
      y: 0
    });
    fired1 = 0;
    return fired2 = 0;
  });
  it('fires when data changes', function() {
    model.onChange('id', callback1);
    model.set('id', 2);
    return expect(fired1).toBe(1);
  });
  it('does not fire when set same data', function() {
    model.onChange('id', callback1);
    model.set('id', 1);
    return expect(fired1).toBe(0);
  });
  it('can get multiple callback params', function() {
    model.onChange('id', [callback1, callback2]);
    model.set('id', 2);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(1);
  });
  it('can get multiple property params', function() {
    model.onChange(['id', 'name'], callback1);
    model.set('id', 2);
    expect(fired1).toBe(1);
    model.set('name', 'newData');
    return expect(fired1).toBe(2);
  });
  it('can get multiple property & callback params', function() {
    model.onChange(['id', 'name'], [callback1, callback2]);
    model.set('id', 2);
    expect(fired1).toBe(1);
    expect(fired2).toBe(1);
    model.set('name', 'newData');
    expect(fired1).toBe(2);
    return expect(fired2).toBe(2);
  });
  it('fires just once if two or more properties has been changed', function() {
    model.onChange(['id', 'name'], callback1);
    model.set({
      id: 2,
      name: 'newTestData',
      x: 1
    });
    return expect(fired1).toBe(1);
  });
  it('returns model in state after change and hash of changes with old values', function() {
    var cb1;
    cb1 = function(newModel, oldValues) {
      expect(newModel).toBe(model);
      expect(newModel.get('id')).toBe(2);
      expect(newModel.get('name')).toBe('test');
      expect(newModel.get('x')).toBe(0);
      expect(newModel.get('y')).toBe(0);
      return expect(oldValues).toEqual({
        id: 1
      });
    };
    model.onChange('id', cb1, model);
    return model.set('id', 2);
  });
  it('when cb not get this', function() {
    var cb1;
    cb1 = function(newModel, oldValues) {
      expect(newModel).toBe(model);
      expect(newModel.get('id')).toBe(2);
      expect(newModel.get('name')).toBe('test');
      expect(newModel.get('x')).toBe(0);
      expect(newModel.get('y')).toBe(0);
      return expect(oldValues).toEqual({
        id: 1
      });
    };
    model.onChange('id', cb1);
    return model.set('id', 2);
  });
  return it('supports "*" - all property subscription', function() {
    model.onChange('*', callback1);
    model.set('id', 2);
    model.set('name', 'newData');
    model.set({
      x: 1,
      y: 1
    });
    return expect(fired1).toBe(3);
  });
});

describe('Model offChange', function() {
  var callback1, callback2, fired1, fired2, model;
  model = null;
  fired1 = 0;
  fired2 = 0;
  callback1 = function() {
    return fired1++;
  };
  callback2 = function() {
    return fired2++;
  };
  beforeEach(function() {
    model = new bg.yabu.model({
      id: 1,
      name: 'test',
      x: 0,
      y: 0
    });
    fired1 = 0;
    return fired2 = 0;
  });
  it('throws custom error when try to unbind unexisted properties', function() {
    var customError;
    customError = null;
    try {
      model.offChange('unexistedProperty');
    } catch (err) {
      customError = err;
    }
    expect(customError instanceof Error).toBeTruthy();
    return expect(customError.name).not.toBe('TypeError');
  });
  it('removes single property callbacks', function() {
    model.onChange('id', [callback1, callback2]);
    model.set('id', 2);
    model.offChange('id');
    model.set('id', 3);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(1);
  });
  it('removes multiple property callbacks', function() {
    model.onChange('id', callback1);
    model.onChange('name', callback2);
    model.set('id', 2);
    model.set('name', 'newData');
    model.offChange(['id', 'name']);
    model.set('id', 3);
    model.set('name', 'anotherNewData');
    expect(fired1).toBe(1);
    return expect(fired2).toBe(1);
  });
  return it('removes "*" callbacks', function() {
    model.onChange('*', callback1);
    model.onChange('id', callback2);
    model.set('id', 2);
    model.offChange('*');
    model.set('id', 3);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(2);
  });
});

describe('Model namespaces', function() {
  var callback1, callback2, fired1, fired2, model;
  model = null;
  fired1 = 0;
  fired2 = 0;
  callback1 = function() {
    return fired1++;
  };
  callback2 = function() {
    return fired2++;
  };
  beforeEach(function() {
    model = new bg.yabu.model({
      id: 1,
      name: 'test',
      x: 0,
      y: 0
    });
    fired1 = 0;
    return fired2 = 0;
  });
  it('adds and removes single callback with namespace', function() {
    model.onChange('id', callback1, 'test');
    model.set('id', 2);
    model.offChange('id', 'test');
    model.set('id', 3);
    return expect(fired1).toBe(1);
  });
  it('adds and removes multiple callbacks with same namespace', function() {
    model.onChange('id', [callback1, callback2], 'test');
    model.set('id', 2);
    model.offChange('id', 'test');
    model.set('id', 3);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(1);
  });
  it('offChange with namespace does not affect global namespace callbacks', function() {
    model.onChange('id', callback1, 'test');
    model.onChange('id', callback2);
    model.set('id', 2);
    model.offChange('id', 'test');
    model.set('id', 3);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(2);
  });
  return it('offChange with "*" namespace removes callbacks from all namespaces', function() {
    model.onChange('id', callback1, 'test1');
    model.onChange('id', callback2, 'test2');
    model.set('id', 2);
    expect(fired1).toBe(1);
    expect(fired2).toBe(1);
    model.offChange('id', '*');
    model.set('id', 3);
    expect(fired1).toBe(1);
    return expect(fired2).toBe(1);
  });
});

describe('Model bind', function() {
  var kineticTarget, model, modelTarget, multiCnv, singleCnv;
  model = null;
  kineticTarget = null;
  modelTarget = null;
  singleCnv = function(value) {
    return ++value;
  };
  multiCnv = function(data) {
    return data.x + data.y;
  };
  beforeEach(function() {
    model = new bg.yabu.model({
      id: 1,
      name: 'test',
      x: 1,
      y: 1
    });
    kineticTarget = new Kinetic.Rect({});
    return modelTarget = new bg.yabu.model({
      x: 1,
      y: 1,
      id: 1
    });
  });
  it('initialize. set target prop when bind to initialized model', function() {
    model.bind('x', kineticTarget, 'x');
    return expect(kineticTarget.attrs.x).toBe(1);
  });
  it('initialize. set target prop when bind to initialized model with namespace', function() {
    model.bind('x', kineticTarget, 'x', 'testns');
    return expect(kineticTarget.attrs.x).toBe(1);
  });
  it('initialize. set target prop when bind to initialized model with converter', function() {
    model.bind('x', kineticTarget, 'x', singleCnv);
    return expect(kineticTarget.attrs.x).toBe(2);
  });
  it('initialize. set target prop when bind to initialized model with namespace and converter', function() {
    model.bind('x', kineticTarget, 'x', 'testns', singleCnv);
    return expect(kineticTarget.attrs.x).toBe(2);
  });
  it('unbind. from single prop', function() {
    model.bind('x', kineticTarget, 'x', 'testns');
    expect(kineticTarget.attrs.x).toBe(1);
    model.set('x', 2);
    expect(kineticTarget.attrs.x).toBe(2);
    model.unbind('x', 'testns');
    model.set('x', 3);
    return expect(kineticTarget.attrs.x).toBe(2);
  });
  it('set. bind single propery to kinetic', function() {
    model.bind('x', kineticTarget, 'x');
    model.set('x', 2);
    return expect(kineticTarget.attrs.x).toBe(2);
  });
  it('multi-bind without converter', function() {
    var customError;
    try {
      model.bind(['x', 'y'], kineticTarget, 'name');
    } catch (err) {
      customError = err;
      expect(customError instanceof Error).toBeTruthy();
      expect(customError.name).not.toBe('TypeError');
    }
    try {
      return model.bind(['x', 'y'], kineticTarget, 'name', 'testns');
    } catch (err) {
      customError = err;
      expect(customError instanceof Error).toBeTruthy();
      return expect(customError.name).not.toBe('TypeError');
    }
  });
  it('multi-bind', function() {
    model.bind(['x', 'y'], kineticTarget, 'name', multiCnv);
    model.set('x', 5);
    model.set('y', 3);
    return expect(kineticTarget.attrs.name).toBe(8);
  });
  it('multi-bind with namespace', function() {
    model.bind(['x', 'y'], kineticTarget, 'name', 'testns', multiCnv);
    model.set('x', 5);
    model.set('y', 3);
    return expect(kineticTarget.attrs.name).toBe(8);
  });
  return it('multi-unbind', function() {
    model.bind(['x', 'y'], kineticTarget, 'name', 'testns', multiCnv);
    model.set('x', 5);
    model.set('y', 3);
    expect(kineticTarget.attrs.name).toBe(8);
    model.unbind(['x', 'y'], 'testns');
    model.set('x', 1);
    model.set('y', 1);
    return expect(kineticTarget.attrs.name).toBe(8);
  });
});

describe('Collection', function() {
  var oModel, yModel;
  yModel = null;
  oModel = null;
  beforeEach(function() {
    var collection;
    yModel = new bg.yabu.model({
      id: 1,
      name: 'test',
      x: 1,
      y: 2
    });
    oModel = {
      x: 1,
      y: 2,
      name: 'test',
      id: 1
    };
    return collection = new bg.yabu.collection();
  });
  it('initialize collection without data', function() {
    var col;
    return col = new bg.yabu.collection();
  });
  it('initialize collection with data as js array of js objects ang get by index', function() {
    var col, mod;
    col = new bg.yabu.collection([
      {
        x: 1,
        y: 2
      }
    ]);
    mod = col.get(0);
    expect(mod.get('x')).toBe(1);
    return expect(mod.get('y')).toBe(2);
  });
  it('collection set data', function() {
    var col, mod;
    col = new bg.yabu.collection();
    col.set([oModel]);
    mod = col.get(0);
    expect(mod.get('x')).toBe(1);
    return expect(mod.get('y')).toBe(2);
  });
  it('collection set data as array of bg.yabu.models', function() {
    var col, mod;
    col = new bg.yabu.collection();
    col.set([yModel]);
    mod = col.get(0);
    expect(mod.get('x')).toBe(1);
    return expect(mod.get('y')).toBe(2);
  });
  it('collection length', function() {
    var col;
    col = new bg.yabu.collection();
    expect(col.length).toBe(0);
    col.set([yModel, oModel]);
    expect(col.length).toBe(2);
    col.push({
      x: 1,
      y: 2
    });
    return expect(col.length).toBe(3);
  });
  return it('collectuion array methods', function() {
    var col, item, item1, item2, item3;
    col = new bg.yabu.collection();
    item1 = {
      x: 1,
      y: 1
    };
    item2 = {
      x: 2,
      y: 2
    };
    item3 = {
      x: 3,
      y: 3
    };
    item = col.pop();
    expect(item).toBe(void 0);
    item = col.shift();
    expect(item).toBe(void 0);
    col.push(item1);
    col.push(item2);
    col.push(item3);
    expect(col.length).toBe(3);
    item = col.pop();
    expect(item.get('x')).toBe(3);
    item = col.pop();
    expect(item.get('x')).toBe(2);
    item = col.pop();
    expect(item.get('x')).toBe(1);
    expect(col.length).toBe(0);
    col.unshift(item1);
    col.unshift(item2);
    col.unshift(item3);
    expect(col.length).toBe(3);
    item = col.shift();
    expect(item.get('x')).toBe(3);
    item = col.shift();
    expect(item.get('x')).toBe(2);
    item = col.shift();
    expect(item.get('x')).toBe(1);
    return expect(col.length).toBe(0);
  });
});
